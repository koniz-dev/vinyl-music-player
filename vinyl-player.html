<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vinyl Player</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand:wght@400&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Patrick Hand', cursive;
            background: rgba(0, 0, 0, 0.5);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .music-player {
            width: 350px;
            height: 600px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 30px;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            transform: translateZ(0);
            backface-visibility: hidden;
        }


        .vinyl-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .vinyl-container {
            position: relative;
            width: 250px;
            height: 250px;
            margin-bottom: 30px;
        }

        .vinyl-record {
            width: 250px;
            height: 250px;
            border-radius: 50%;
            background: radial-gradient(circle at center, #1a1a1a 30%, #000 70%);
            position: relative;
            animation: none;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
            will-change: transform;
        }

        .vinyl-record.paused {
            animation-play-state: paused;
        }

        .vinyl-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.3);
        }

        .album-art {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><linearGradient id="g" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:%23ff6b6b"/><stop offset="100%" style="stop-color:%234ecdc4"/></linearGradient></defs><circle cx="50" cy="50" r="45" fill="url(%23g)"/><path d="M30 40 Q35 35 40 40 L45 50 Q50 45 55 50 L60 60 Q55 65 50 60 L45 50 Q40 55 35 50 Z" fill="white" opacity="0.8"/></svg>') center/cover;
            object-fit: cover;
        }

        .vinyl-grooves {
            position: absolute;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .groove-1 { width: 200px; height: 200px; top: 25px; left: 25px; }
        .groove-2 { width: 170px; height: 170px; top: 40px; left: 40px; }
        .groove-3 { width: 140px; height: 140px; top: 55px; left: 55px; }

        .tonearm {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 3px;
            height: 120px;
            background: linear-gradient(to bottom, #fff, #ccc);
            transform-origin: top center;
            transform: rotate(25deg);
            border-radius: 2px;
            transition: transform 0.3s ease;
            will-change: transform;
        }

        .tonearm::before {
            content: '';
            position: absolute;
            top: -8px;
            left: -4px;
            width: 10px;
            height: 10px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .tonearm::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: -2px;
            width: 6px;
            height: 10px;
            background: #666;
            border-radius: 3px;
        }

        .tonearm.playing {
            transform: rotate(15deg);
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .song-info {
            text-align: center;
            color: white;
        }

        .song-title {
            font-size: 24px;
            font-weight: bold;
            margin-top: 16px;
            letter-spacing: 2px;
        }

        .artist-name {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
        }

        .lyrics-text {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
            margin-top: 10px;
            display: block;
            transition: opacity 0.3s ease-in-out;
            min-height: 20px;
        }

        .progress-container {
            width: 100%;
            padding: 0 30px;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            position: relative;
            cursor: pointer;
        }

        .progress {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 2px;
            width: 0%;
            transition: width 0.1s ease;
        }

        .progress-time {
            display: flex;
            justify-content: space-between;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            margin-top: 8px;
        }

        .controls {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 10px 30px 30px;
        }

        .control-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            will-change: transform;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .play-pause-btn {
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.1);
            font-size: 32px;
        }

        .play-pause-btn:hover {
            transform: scale(1.1);
        }


        /* Particle effects */
        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); opacity: 0; }
            50% { transform: translateY(-20px); opacity: 1; }
        }

        /* Audio visualizer bars */
        .visualizer {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 4px;
            height: 30px;
            align-items: flex-end;
        }

        .bar {
            width: 3px;
            background: linear-gradient(to top, #667eea, #764ba2);
            border-radius: 1px;
            animation: pulse 0.8s ease-in-out infinite alternate;
            will-change: transform;
        }

        .bar:nth-child(1) { animation-delay: 0s; height: 20%; }
        .bar:nth-child(2) { animation-delay: 0.1s; height: 60%; }
        .bar:nth-child(3) { animation-delay: 0.2s; height: 40%; }
        .bar:nth-child(4) { animation-delay: 0.3s; height: 80%; }
        .bar:nth-child(5) { animation-delay: 0.4s; height: 30%; }

        @keyframes pulse {
            to { transform: scaleY(1.5); }
        }

        .visualizer.paused .bar {
            animation-play-state: paused;
        }

        @media (max-width: 400px) {
            .music-player {
                width: 320px;
                height: 550px;
            }
            
            .vinyl-container {
                width: 200px;
                height: 200px;
            }
            
            .vinyl-record {
                width: 200px;
                height: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="music-player">

        <div class="vinyl-section">
            <div class="vinyl-container">
                <div class="vinyl-record" id="vinyl">
                    <div class="vinyl-grooves groove-1"></div>
                    <div class="vinyl-grooves groove-2"></div>
                    <div class="vinyl-grooves groove-3"></div>
                    <div class="vinyl-center">
                        <div class="album-art" id="albumArt"></div>
                    </div>
                </div>
                <div class="tonearm" id="tonearm"></div>
            </div>

            <div class="visualizer" id="visualizer">
                <div class="bar"></div>
                <div class="bar"></div>
                <div class="bar"></div>
                <div class="bar"></div>
                <div class="bar"></div>
            </div>

            <div class="song-info">
                <div class="song-title" id="songTitle"></div>
                <div class="artist-name" id="artistName"></div>
                <div class="lyrics-text" id="lyricsText"></div>
            </div>
        </div>

        <div class="progress-container">
            <div class="progress-bar" id="progressBar">
                <div class="progress" id="progress"></div>
            </div>
            <div class="progress-time">
                <span id="currentTime">00:00</span>
                <span id="totalTime">00:00</span>
            </div>
        </div>

        <div class="controls">
            <button class="control-btn" id="muteBtn" disabled style="opacity: 0.5; cursor: not-allowed;">üîä</button>
            <button class="control-btn" disabled style="opacity: 0.5; cursor: not-allowed;">‚èÆ</button>
            <button class="control-btn play-pause-btn" id="playPauseBtn" disabled style="opacity: 0.5; cursor: not-allowed;">‚ñ∂</button>
            <button class="control-btn" disabled style="opacity: 0.5; cursor: not-allowed;">‚è≠</button>
            <button class="control-btn" id="repeatBtn" disabled style="opacity: 0.5; cursor: not-allowed;">‚Üª</button>
        </div>
    </div>

    <script>
        let isPlaying = false;
        let currentTime = 0; // seconds
        let totalTime = 0; // seconds
        let progressInterval;
        let lyricsInterval;
        // No longer need currentLyricIndex as lyrics are managed by timestamp
        let audioElement = null;
        let isMuted = false;
        let isRepeat = false;

        // Lyrics array will be updated from settings
        let lyrics = [];

        const vinyl = document.getElementById('vinyl');
        const tonearm = document.getElementById('tonearm');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const progress = document.getElementById('progress');
        const currentTimeEl = document.getElementById('currentTime');
        const visualizer = document.getElementById('visualizer');
        const progressBar = document.getElementById('progressBar');
        const lyricsText = document.getElementById('lyricsText');
        const muteBtn = document.getElementById('muteBtn');
        const repeatBtn = document.getElementById('repeatBtn');

        // Initialize player
        function init() {
            updateProgress();
            updateTonearm();
            updateLyrics(); // Will show empty lyrics if not playing music
            updateVisualizerPosition(); // Set initial visualizer position
            if (isPlaying) {
                startProgressTimer();
                startLyricsTimer();
            }
        }

        // Function to update lyrics based on current time
        function updateLyrics() {
            // Only show lyrics when music is loaded and playing
            if (!audioElement || !isPlaying) {
                lyricsText.textContent = '';
                updateVisualizerPosition(); // Update visualizer position
                return;
            }

            // Find lyrics that match current time
            const currentLyric = getCurrentLyric(currentTime);
            
            if (currentLyric) {
                // Found lyrics that match current time
                if (currentLyric.text !== lyricsText.textContent) {
                    // Add fade out/in effect when changing lyrics
                    lyricsText.style.opacity = '0.5';
                    setTimeout(() => {
                        lyricsText.textContent = currentLyric.text;
                        lyricsText.style.opacity = '1';
                        updateVisualizerPosition(); // Update visualizer position
                    }, 150);
                }
            } else {
                // No lyrics match current time
                if (lyricsText.textContent !== '') {
                    lyricsText.textContent = '';
                    updateVisualizerPosition(); // Update visualizer position
                }
            }
        }

        // Function to find current lyrics based on time
        function getCurrentLyric(time) {
            // Check if lyrics array is empty
            if (!lyrics || lyrics.length === 0) {
                return null;
            }
            
            for (let i = 0; i < lyrics.length; i++) {
                // Check if lyrics[i] element exists and has start, end properties
                if (lyrics[i] && typeof lyrics[i].start !== 'undefined' && typeof lyrics[i].end !== 'undefined') {
                    // Only show lyrics in exact time range [start, end)
                    if (time >= lyrics[i].start && time < lyrics[i].end) {
                        return lyrics[i];
                    }
                }
            }
            
            // If no matching lyrics found (before start, in gap, after end), return null
            return null;
        }

        // Function to start lyrics timer (no longer needed as integrated with timeupdate)
        function startLyricsTimer() {
            // Lyrics are now updated through timeupdate event
        }

        // Function to stop lyrics timer (no longer needed)
        function stopLyricsTimer() {
            // Lyrics are now updated through timeupdate event
        }

        function restartAudio() {
            if (!audioElement) return;
            
            audioElement.currentTime = 0;
            currentTime = 0;
            updateProgress();
            
            // Small delay to ensure reset is complete
            setTimeout(() => {
                audioElement.play().then(() => {
                    isPlaying = true;
                    updatePlayerState();
                    startProgressTimer();
                    startLyricsTimer();
                }).catch(error => {
                    isPlaying = false;
                    updatePlayerState();
                });
            }, 100);
        }

        function togglePlayPause() {
            if (!audioElement) return;
            
            if (isPlaying) {
                // Currently playing, so pause
                audioElement.pause();
                isPlaying = false;
                updatePlayerState();
                stopProgressTimer();
                stopLyricsTimer();
            } else {
                // Currently paused, so play
                if (audioElement.ended) {
                    restartAudio();
                } else {
                    // Use promise to handle play properly
                    audioElement.play().then(() => {
                        isPlaying = true;
                        updatePlayerState();
                        startProgressTimer();
                        startLyricsTimer();
                    }).catch(error => {
                        isPlaying = false;
                        updatePlayerState();
                    });
                }
            }
        }

        function startProgressTimer() {
            // Progress is now handled by audio timeupdate event
            // This function is kept for compatibility
        }

        function stopProgressTimer() {
            clearInterval(progressInterval);
        }

        function updateProgress() {
            if (totalTime > 0) {
                const progressPercent = (currentTime / totalTime) * 100;
                progress.style.width = `${progressPercent}%`;
            }
            currentTimeEl.textContent = formatTime(currentTime);
        }

        function updateTonearm() {
            if (isPlaying) {
                tonearm.classList.add('playing');
            } else {
                tonearm.classList.remove('playing');
            }
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // Progress bar click (optimized with throttling)
        let isProgressUpdating = false;
        progressBar.addEventListener('click', (e) => {
            if (isProgressUpdating || !audioElement) return;
            isProgressUpdating = true;
            
            const rect = progressBar.getBoundingClientRect();
            const percent = (e.clientX - rect.left) / rect.width;
            const newTime = Math.floor(percent * totalTime);
            
            // Update both currentTime and audioElement.currentTime
            currentTime = newTime;
            audioElement.currentTime = newTime;
            updateProgress();
            
            setTimeout(() => {
                isProgressUpdating = false;
            }, 100);
        });

        function previousTrack() {
            currentTime = 0;
            updateProgress();
            updateLyrics(); // Will show empty lyrics if not playing music
            // Add track switching logic here
            // createParticles();
        }

        function nextTrack() {
            currentTime = 0;
            updateProgress();
            updateLyrics(); // Will show empty lyrics if not playing music
            // Add track switching logic here
            // createParticles();
        }


        // Create floating particles effect (optimized)
        function createParticles() {
            const vinylSection = document.querySelector('.vinyl-section');
            const fragment = document.createDocumentFragment();
            
            for (let i = 0; i < 6; i++) { // Reduced from 10 to 6 particles
                const particle = document.createElement('div');
                particle.classList.add('particle');
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 2 + 's';
                fragment.appendChild(particle);
            }
            
            vinylSection.appendChild(fragment);
            
            // Clean up particles after animation
            setTimeout(() => {
                const particles = vinylSection.querySelectorAll('.particle');
                particles.forEach(particle => particle.remove());
            }, 3000);
        }

        // Message listener for auto play and real-time updates
        window.addEventListener('message', function(event) {
            if (event.data.type === 'START_PLAY') {
                startPlaying(event.data);
            } else if (event.data.type === 'UPDATE_SONG_TITLE') {
                updateSongTitle(event.data.songTitle);
            } else if (event.data.type === 'UPDATE_ARTIST_NAME') {
                updateArtistName(event.data.artistName);
            } else if (event.data.type === 'UPDATE_ALBUM_ART') {
                updateAlbumArt(event.data.imageUrl);
            } else if (event.data.type === 'REMOVE_ALBUM_ART') {
                removeAlbumArt();
            } else if (event.data.type === 'UPDATE_LYRICS') {
                updateLyricsFromSettings(event.data.lyrics);
            }
        });

        // Function to update song title in real-time
        function updateSongTitle(title) {
            const songTitleElement = document.getElementById('songTitle');
            if (songTitleElement) {
                songTitleElement.textContent = title || ''; // Show empty string if title is empty
            }
            // Update visualizer position after title change
            updateVisualizerPosition();
        }

        // Function to update artist name in real-time
        function updateArtistName(artist) {
            const artistNameElement = document.getElementById('artistName');
            if (artistNameElement) {
                artistNameElement.textContent = artist || ''; // Show empty string if artist is empty
            }
            // Update visualizer position after artist change
            updateVisualizerPosition();
        }

        // Function to update lyrics from settings
        function updateLyricsFromSettings(newLyrics) {
            if (newLyrics && newLyrics.length > 0) {
                // Update the global lyrics array
                lyrics.length = 0; // Clear existing lyrics
                
                // Only add valid lyrics (with start, end, text)
                newLyrics.forEach(lyric => {
                    if (lyric && 
                        typeof lyric.start !== 'undefined' && 
                        typeof lyric.end !== 'undefined' && 
                        typeof lyric.text !== 'undefined' && 
                        lyric.text.trim() !== '') {
                        lyrics.push(lyric);
                    }
                });
                
                
                // Update lyrics display if music is loaded
                if (audioElement) {
                    // Only show lyrics if playing music and have lyrics matching current time
                    if (isPlaying) {
                        updateLyrics();
                    } else {
                        // If not playing music, empty lyrics but still occupy space
                        lyricsText.textContent = '';
                        updateVisualizerPosition();
                    }
                } else {
                    // If no music, empty lyrics but still occupy space
                    lyricsText.textContent = '';
                }
            }
        }

        // Function to update visualizer position based on content
        function updateVisualizerPosition() {
            const songTitleElement = document.getElementById('songTitle');
            const artistNameElement = document.getElementById('artistName');
            const lyricsTextElement = document.getElementById('lyricsText');
            const visualizer = document.getElementById('visualizer');
            
            if (songTitleElement && artistNameElement && lyricsTextElement && visualizer) {
                const hasTitle = songTitleElement.textContent.trim() !== '';
                const hasArtist = artistNameElement.textContent.trim() !== '';
                const hasLyrics = lyricsTextElement.textContent.trim() !== '';
                
                let bottomValue;
                if (hasTitle && hasArtist) {
                    bottomValue = '136px'; // Title and artist present
                } else if (hasTitle || hasArtist) {
                    bottomValue = '120px'; // Either title or artist present
                } else {
                    bottomValue = '88px'; // Neither present
                }
                
                visualizer.style.bottom = bottomValue;
            }
        }

        // Function to update album art
        function updateAlbumArt(imageUrl) {
            const musicPlayer = document.querySelector('.music-player');
            const albumArt = document.getElementById('albumArt');
            
            if (musicPlayer && imageUrl) {
                // Set background image for music player with beautiful effects
                musicPlayer.style.backgroundImage = `url(${imageUrl})`;
                musicPlayer.style.backgroundSize = 'cover';
                musicPlayer.style.backgroundPosition = 'center';
                musicPlayer.style.backgroundRepeat = 'no-repeat';
                
                // Add beautiful overlay effects
                musicPlayer.style.position = 'relative';
                
                // Create or update overlay
                let overlay = musicPlayer.querySelector('.album-overlay');
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.className = 'album-overlay';
                    overlay.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: linear-gradient(135deg, 
                            rgba(0, 0, 0, 0.4) 0%, 
                            rgba(0, 0, 0, 0.6) 50%, 
                            rgba(0, 0, 0, 0.4) 100%);
                        backdrop-filter: blur(2px);
                        border-radius: 30px;
                        pointer-events: none;
                        z-index: 1;
                    `;
                    musicPlayer.appendChild(overlay);
                }
                
                // Ensure content is above overlay
                const vinylSection = musicPlayer.querySelector('.vinyl-section');
                const progressContainer = musicPlayer.querySelector('.progress-container');
                const controls = musicPlayer.querySelector('.controls');
                
                if (vinylSection) vinylSection.style.position = 'relative';
                if (vinylSection) vinylSection.style.zIndex = '2';
                if (progressContainer) progressContainer.style.position = 'relative';
                if (progressContainer) progressContainer.style.zIndex = '2';
                if (controls) controls.style.position = 'relative';
                if (controls) controls.style.zIndex = '2';
            }
            
            if (albumArt && imageUrl) {
                // Set background image for album art with subtle effects
                albumArt.style.backgroundImage = `url(${imageUrl})`;
                albumArt.style.backgroundSize = 'cover';
                albumArt.style.backgroundPosition = 'center';
                albumArt.style.backgroundRepeat = 'no-repeat';
                albumArt.style.borderRadius = '50%';
                albumArt.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.3), inset 0 0 0 1px rgba(255, 255, 255, 0.1)';
            }
        }

        // Function to remove album art
        function removeAlbumArt() {
            const musicPlayer = document.querySelector('.music-player');
            const albumArt = document.getElementById('albumArt');
            
            if (musicPlayer) {
                // Remove background image from music player
                musicPlayer.style.backgroundImage = '';
                musicPlayer.style.backgroundSize = '';
                musicPlayer.style.backgroundPosition = '';
                musicPlayer.style.backgroundRepeat = '';
                
                // Remove overlay
                const overlay = musicPlayer.querySelector('.album-overlay');
                if (overlay) {
                    overlay.remove();
                }
                
                // Reset z-index for content
                const vinylSection = musicPlayer.querySelector('.vinyl-section');
                const progressContainer = musicPlayer.querySelector('.progress-container');
                const controls = musicPlayer.querySelector('.controls');
                
                if (vinylSection) vinylSection.style.position = '';
                if (vinylSection) vinylSection.style.zIndex = '';
                if (progressContainer) progressContainer.style.position = '';
                if (progressContainer) progressContainer.style.zIndex = '';
                if (controls) controls.style.position = '';
                if (controls) controls.style.zIndex = '';
            }
            
            if (albumArt) {
                // Remove background image and effects from album art
                albumArt.style.backgroundImage = '';
                albumArt.style.backgroundSize = '';
                albumArt.style.backgroundPosition = '';
                albumArt.style.backgroundRepeat = '';
                albumArt.style.borderRadius = '';
                albumArt.style.boxShadow = '';
            }
        }

        function startPlaying(data) {
            // Create audio element
            audioElement = new Audio(data.audioUrl);
            
            // Update song title and artist name if provided
            if (data.songTitle !== undefined) {
                updateSongTitle(data.songTitle);
            }
            if (data.artistName !== undefined) {
                updateArtistName(data.artistName);
            }
            
            // Update album art if provided
            if (data.albumArtUrl) {
                updateAlbumArt(data.albumArtUrl);
            }
            
            // Update visualizer position after all updates
            updateVisualizerPosition();
            
            // Enable controls
            enableControls();
            
            // Set up audio events
            audioElement.addEventListener('loadedmetadata', function() {
                totalTime = Math.floor(audioElement.duration);
                document.getElementById('totalTime').textContent = formatTime(totalTime);
            });
            
            audioElement.addEventListener('timeupdate', function() {
                currentTime = Math.floor(audioElement.currentTime);
                updateProgress();
                updateLyrics(); // Update lyrics in real time
            });
            
            audioElement.addEventListener('ended', function() {
                if (isRepeat) {
                    // Repeat current track
                    audioElement.currentTime = 0;
                    audioElement.play();
                } else {
                    // Stop completely when song ends
                    isPlaying = false;
                    updatePlayerState();
                    stopProgressTimer();
                    stopLyricsTimer();
                    updateTonearm();
                    // Reset current time for next play
                    currentTime = 0;
                    updateProgress();
                }
            });
            
            // Start playing
            audioElement.play().then(() => {
                isPlaying = true;
                updatePlayerState();
                startProgressTimer();
                startLyricsTimer();
            });
            
            // Update lyrics immediately when music is loaded
            updateLyrics();
        }

        function enableControls() {
            const controls = document.querySelectorAll('.control-btn');
            controls.forEach(btn => {
                btn.disabled = false;
                btn.style.opacity = '1';
                btn.style.cursor = 'pointer';
            });
            
            // Reset button states
            muteBtn.textContent = 'üîä';
            muteBtn.style.background = 'rgba(255, 255, 255, 0.1)';
            repeatBtn.style.background = 'rgba(255, 255, 255, 0.1)';
            repeatBtn.style.color = 'white';
            isRepeat = false;
        }

        function updatePlayerState() {
            const vinyl = document.getElementById('vinyl');
            const tonearm = document.getElementById('tonearm');
            const visualizer = document.getElementById('visualizer');
            const playPauseBtn = document.getElementById('playPauseBtn');
            
            if (isPlaying) {
                vinyl.style.animation = 'spin 8s linear infinite';
                tonearm.classList.add('playing');
                visualizer.style.display = 'flex';
                playPauseBtn.textContent = '‚è∏';
            } else {
                vinyl.style.animation = 'none';
                tonearm.classList.remove('playing');
                visualizer.style.display = 'none';
                playPauseBtn.textContent = '‚ñ∂';
            }
            
            // Update lyrics when playback state changes
            updateLyrics();
        }

        // Event listeners for buttons
        playPauseBtn.addEventListener('click', function() {
            togglePlayPause();
        });

        muteBtn.addEventListener('click', function() {
            if (!audioElement) return;
            
            isMuted = !isMuted;
            audioElement.muted = isMuted;
            
            if (isMuted) {
                muteBtn.textContent = 'üîá';
                muteBtn.style.background = 'rgba(255, 255, 255, 0.1)';
            } else {
                muteBtn.textContent = 'üîä';
                muteBtn.style.background = 'rgba(255, 255, 255, 0.1)';
            }
        });

        repeatBtn.addEventListener('click', function() {
            if (!audioElement) return;
            
            isRepeat = !isRepeat;
            
            if (isRepeat) {
                repeatBtn.style.background = 'rgba(102, 126, 234, 0.3)';
                repeatBtn.style.color = '#667eea';
            } else {
                repeatBtn.style.background = 'rgba(255, 255, 255, 0.1)';
                repeatBtn.style.color = 'white';
            }
        });

        // Initialize the player
        init();

        // Add some visual effects on load
        // setTimeout(createParticles, 1000);

        // Export MP4 functionality
        let mediaRecorder = null;
        let recordedChunks = [];
        let exportCanvas = null;
        let exportCtx = null;
        let exportAnimationId = null;
        let vinylRotation = 0;
        let albumArtImage = null;
        let exportAudio = null;
        let exportLyrics = [];
        let isExporting = false; // Flag to prevent duplicate exports

        // Create export canvas
        function createExportCanvas() {
            exportCanvas = document.createElement('canvas');
            
            // Get canvas dimensions with fallback system
            let canvasWidth = 720; // Default fallback
            let canvasHeight = 1280; // Default fallback
            
            // Try to get dimensions from various sources
            const dimensionSources = [
                // 1. Vinyl player dimensions
                () => {
                    const vinylPlayer = document.querySelector('.vinyl-player');
                    if (vinylPlayer) {
                        const rect = vinylPlayer.getBoundingClientRect();
                        if (rect.width > 0 && rect.height > 0) {
                            return { width: rect.width, height: rect.height };
                        }
                    }
                    return null;
                },
                // 2. Iframe dimensions
                () => {
                    const iframe = window.frameElement;
                    if (iframe) {
                        const rect = iframe.getBoundingClientRect();
                        if (rect.width > 0 && rect.height > 0) {
                            return { width: rect.width, height: rect.height };
                        }
                    }
                    return null;
                },
                // 3. Window dimensions with aspect ratio
                () => {
                    const windowWidth = window.innerWidth;
                    const windowHeight = window.innerHeight;
                    if (windowWidth > 0 && windowHeight > 0) {
                        const aspectRatio = 9 / 16; // Mobile portrait ratio
                        if (windowWidth / windowHeight > aspectRatio) {
                            return { width: windowHeight * aspectRatio, height: windowHeight };
                        } else {
                            return { width: windowWidth, height: windowWidth / aspectRatio };
                        }
                    }
                    return null;
                }
            ];
            
            // Try each source until we get valid dimensions
            for (const getDimensions of dimensionSources) {
                try {
                    const dimensions = getDimensions();
                    if (dimensions) {
                        canvasWidth = dimensions.width;
                        canvasHeight = dimensions.height;
                        break; // Found valid dimensions, stop trying
                    }
                } catch (e) {
                    // Continue to next source
                }
            }
            
            // Ensure minimum dimensions for quality
            exportCanvas.width = Math.max(canvasWidth, 400);
            exportCanvas.height = Math.max(canvasHeight, 600);
            
            exportCtx = exportCanvas.getContext('2d');
            
            // Set canvas style for better rendering
            exportCtx.imageSmoothingEnabled = true;
            exportCtx.imageSmoothingQuality = 'high';
        }

        // Render vinyl player to canvas
        function renderToCanvas() {
            if (!exportCtx) return;

            // Clear canvas with music player background (like CSS .music-player)
            exportCtx.fillStyle = 'rgba(0, 0, 0, 0.8)'; // CSS background: rgba(0, 0, 0, 0.8)
            exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
            
            // Add rounded corners effect (like CSS border-radius: 30px)
            exportCtx.save();
            exportCtx.beginPath();
            // Use manual rounded rect for better browser compatibility
            const radius = 30;
            exportCtx.moveTo(radius, 0);
            exportCtx.lineTo(exportCanvas.width - radius, 0);
            exportCtx.quadraticCurveTo(exportCanvas.width, 0, exportCanvas.width, radius);
            exportCtx.lineTo(exportCanvas.width, exportCanvas.height - radius);
            exportCtx.quadraticCurveTo(exportCanvas.width, exportCanvas.height, exportCanvas.width - radius, exportCanvas.height);
            exportCtx.lineTo(radius, exportCanvas.height);
            exportCtx.quadraticCurveTo(0, exportCanvas.height, 0, exportCanvas.height - radius);
            exportCtx.lineTo(0, radius);
            exportCtx.quadraticCurveTo(0, 0, radius, 0);
            exportCtx.clip();
            
            // Draw blurred album art background if available
            if (albumArtImage) {
                exportCtx.save();
                exportCtx.filter = 'blur(30px) brightness(0.4) saturate(1.2)';
                
                // Calculate proper scaling to cover entire canvas
                const imgAspect = albumArtImage.width / albumArtImage.height;
                const canvasAspect = exportCanvas.width / exportCanvas.height;
                
                let drawWidth, drawHeight, offsetX, offsetY;
                
                if (imgAspect > canvasAspect) {
                    drawHeight = exportCanvas.height + 200;
                    drawWidth = drawHeight * imgAspect;
                    offsetX = (exportCanvas.width - drawWidth) / 2;
                    offsetY = -100;
                } else {
                    drawWidth = exportCanvas.width + 200;
                    drawHeight = drawWidth / imgAspect;
                    offsetX = -100;
                    offsetY = (exportCanvas.height - drawHeight) / 2;
                }
                
                exportCtx.drawImage(albumArtImage, offsetX, offsetY, drawWidth, drawHeight);
                exportCtx.restore();
                
                // Add dark overlay
                exportCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
            }
            
            exportCtx.restore();

            // Draw vinyl record (centered, responsive size) - matching CSS exactly
            const centerX = exportCanvas.width / 2;
            const centerY = exportCanvas.height * 0.4; // Higher up for mobile layout
            const vinylRadius = Math.min(exportCanvas.width, exportCanvas.height) * 0.25; // Responsive size

            // Vinyl background with realistic shadow and styling (like CSS box-shadow: 0 0 50px rgba(0, 0, 0, 0.5))
            exportCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';
            exportCtx.shadowBlur = 60;
            exportCtx.shadowOffsetX = 0;
            exportCtx.shadowOffsetY = 15;
            
            // Vinyl record with realistic gradient (like CSS radial-gradient(circle at center, #1a1a1a 30%, #000 70%))
            const vinylGradient = exportCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, vinylRadius);
            vinylGradient.addColorStop(0, '#1a1a1a');
            vinylGradient.addColorStop(0.3, '#1a1a1a');
            vinylGradient.addColorStop(0.7, '#000000');
            vinylGradient.addColorStop(1, '#000000');
            
            exportCtx.fillStyle = vinylGradient;
            exportCtx.beginPath();
            exportCtx.arc(centerX, centerY, vinylRadius, 0, 2 * Math.PI);
            exportCtx.fill();
            
            // Draw vinyl grooves (like CSS .vinyl-grooves) - MORE DETAILED
            exportCtx.shadowBlur = 0;
            
            // Multiple detailed grooves
            for (let i = 1; i <= 8; i++) {
                const grooveRadius = vinylRadius * (0.9 - i * 0.08);
                const opacity = 0.15 - (i * 0.015);
                
                exportCtx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                exportCtx.lineWidth = 0.5 + (i * 0.1);
                exportCtx.beginPath();
                exportCtx.arc(centerX, centerY, grooveRadius, 0, 2 * Math.PI);
                exportCtx.stroke();
            }
            
            // Add radial lines for vinyl effect
            exportCtx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            exportCtx.lineWidth = 0.5;
            for (let i = 0; i < 12; i++) {
                const angle = (i * Math.PI * 2) / 12;
                const startRadius = vinylRadius * 0.3;
                const endRadius = vinylRadius * 0.9;
                
                exportCtx.beginPath();
                exportCtx.moveTo(
                    centerX + Math.cos(angle) * startRadius,
                    centerY + Math.sin(angle) * startRadius
                );
                exportCtx.lineTo(
                    centerX + Math.cos(angle) * endRadius,
                    centerY + Math.sin(angle) * endRadius
                );
                exportCtx.stroke();
            }

            // Draw tonearm (like CSS .tonearm)
            const tonearmX = centerX + vinylRadius * 0.8;
            const tonearmY = centerY - vinylRadius * 0.8;
            const tonearmLength = vinylRadius * 0.48; // 120px for 250px vinyl
            
            exportCtx.save();
            exportCtx.translate(tonearmX, tonearmY);
            exportCtx.rotate(25 * Math.PI / 180); // 25 degrees like CSS
            
            // Tonearm body (like CSS background: linear-gradient(to bottom, #fff, #ccc))
            const tonearmGradient = exportCtx.createLinearGradient(0, 0, 0, tonearmLength);
            tonearmGradient.addColorStop(0, '#fff');
            tonearmGradient.addColorStop(1, '#ccc');
            
            exportCtx.fillStyle = tonearmGradient;
            exportCtx.fillRect(-1.5, 0, 3, tonearmLength);
            
            // Tonearm pivot (like CSS ::before)
            exportCtx.fillStyle = '#fff';
            exportCtx.beginPath();
            exportCtx.arc(0, -8, 5, 0, 2 * Math.PI);
            exportCtx.fill();
            
            // Tonearm needle (like CSS ::after)
            exportCtx.fillStyle = '#666';
            exportCtx.fillRect(-1, tonearmLength - 5, 3, 10);
            
            exportCtx.restore();

            // Vinyl center with CSS styling (like CSS .vinyl-center)
            const centerRadius = vinylRadius * 0.48; // 120px for 250px vinyl (like CSS width: 120px)
            
            // Vinyl center background (like CSS background: linear-gradient(135deg, #667eea 0%, #764ba2 100%))
            const centerGradient = exportCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, centerRadius);
            centerGradient.addColorStop(0, '#ff6b6b'); // Pink-orange center
            centerGradient.addColorStop(0.3, '#4ecdc4'); // Teal
            centerGradient.addColorStop(0.6, '#667eea'); // Blue
            centerGradient.addColorStop(1, '#764ba2'); // Purple
            
            // Vinyl center shadow (like CSS box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.3))
            exportCtx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            exportCtx.shadowBlur = 20;
            exportCtx.shadowOffsetX = 0;
            exportCtx.shadowOffsetY = 0;
            
            exportCtx.fillStyle = centerGradient;
            exportCtx.beginPath();
            exportCtx.arc(centerX, centerY, centerRadius, 0, 2 * Math.PI);
            exportCtx.fill();
            
            // Album art with realistic styling (like CSS .album-art)
            const albumArtRadius = centerRadius * 0.83; // 100px for 120px center (like CSS width: 100px)
            if (albumArtImage) {
                // Album art shadow with realistic depth
                exportCtx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                exportCtx.shadowBlur = 15;
                exportCtx.shadowOffsetX = 0;
                exportCtx.shadowOffsetY = 8;
                
                exportCtx.save();
                exportCtx.beginPath();
                exportCtx.arc(centerX, centerY, albumArtRadius, 0, 2 * Math.PI);
                exportCtx.clip();
                
                // Draw album art with slight rotation for dynamic effect
                exportCtx.save();
                exportCtx.translate(centerX, centerY);
                exportCtx.rotate((vinylRotation * 0.1 * Math.PI) / 180); // Slow rotation
                exportCtx.translate(-centerX, -centerY);
                exportCtx.drawImage(albumArtImage, centerX - albumArtRadius, centerY - albumArtRadius, 
                                  albumArtRadius * 2, albumArtRadius * 2);
                exportCtx.restore();
                
                exportCtx.restore();
                
                // Album art border with gradient
                exportCtx.shadowBlur = 0;
                const borderGradient = exportCtx.createRadialGradient(centerX, centerY, albumArtRadius - 2, centerX, centerY, albumArtRadius);
                borderGradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
                borderGradient.addColorStop(1, 'rgba(255, 255, 255, 0.3)');
                exportCtx.strokeStyle = borderGradient;
                exportCtx.lineWidth = 3;
                exportCtx.beginPath();
                exportCtx.arc(centerX, centerY, albumArtRadius, 0, 2 * Math.PI);
                exportCtx.stroke();
            } else {
                // Default album art placeholder with realistic gradient (like CSS background)
                const albumGradient = exportCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, albumArtRadius);
                albumGradient.addColorStop(0, '#ff6b6b');
                albumGradient.addColorStop(0.5, '#4ecdc4');
                albumGradient.addColorStop(1, '#667eea');
                exportCtx.fillStyle = albumGradient;
                exportCtx.beginPath();
                exportCtx.arc(centerX, centerY, albumArtRadius, 0, 2 * Math.PI);
                exportCtx.fill();
                
                // Add subtle border
                exportCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                exportCtx.lineWidth = 2;
                exportCtx.beginPath();
                exportCtx.arc(centerX, centerY, albumArtRadius, 0, 2 * Math.PI);
                exportCtx.stroke();
                
                // Add music note icon with shadow
                exportCtx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                exportCtx.shadowBlur = 5;
                exportCtx.shadowOffsetX = 0;
                exportCtx.shadowOffsetY = 2;
                exportCtx.fillStyle = '#ffffff';
                exportCtx.font = `${albumArtRadius * 0.4}px Arial`;
                exportCtx.textAlign = 'center';
                exportCtx.fillText('üéµ', centerX, centerY + albumArtRadius * 0.15);
                exportCtx.shadowBlur = 0;
            }

            // Visualizer bars removed as requested

            // Song info with realistic typography (like real UI)
            const songTitle = document.getElementById('songTitle').textContent;
            const artistName = document.getElementById('artistName').textContent;
            const lyricsText = document.getElementById('lyricsText').textContent;

            // Song title with realistic styling (like CSS .song-title)
            exportCtx.shadowColor = 'rgba(0, 0, 0, 0.9)';
            exportCtx.shadowBlur = 20;
            exportCtx.shadowOffsetX = 0;
            exportCtx.shadowOffsetY = 4;
            
            exportCtx.fillStyle = '#ffffff';
            exportCtx.font = `bold ${exportCanvas.width * 0.06}px 'Patrick Hand', Arial, sans-serif`;
            exportCtx.textAlign = 'center';
            exportCtx.fillText(songTitle, centerX, centerY + vinylRadius + 100);

            if (artistName) {
                // Artist name (like CSS .artist-name)
                exportCtx.font = `${exportCanvas.width * 0.04}px 'Patrick Hand', Arial, sans-serif`;
                exportCtx.fillStyle = 'rgba(255, 255, 255, 0.7)'; // CSS color: rgba(255, 255, 255, 0.7)
                exportCtx.fillText(artistName, centerX, centerY + vinylRadius + 140);
            }
            
            exportCtx.shadowBlur = 0;

            // Display current lyrics based on audio time (like real UI)
            if (exportAudio && exportLyrics.length > 0) {
                const currentTime = exportAudio.currentTime;
                const currentLyric = exportLyrics.find(lyric => 
                    currentTime >= lyric.start && currentTime <= lyric.end
                );
                
                if (currentLyric) {
                    exportCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                    exportCtx.shadowBlur = 10;
                    exportCtx.font = `${exportCanvas.width * 0.035}px 'Patrick Hand', Arial, sans-serif`;
                    exportCtx.fillStyle = '#ffd700';
                    exportCtx.fillText(currentLyric.text, centerX, centerY + vinylRadius + 180);
                    exportCtx.shadowBlur = 0;
                }
            } else if (lyricsText) {
                exportCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                exportCtx.shadowBlur = 10;
                exportCtx.font = `${exportCanvas.width * 0.035}px 'Patrick Hand', Arial, sans-serif`;
                exportCtx.fillStyle = '#ffd700';
                exportCtx.fillText(lyricsText, centerX, centerY + vinylRadius + 180);
                exportCtx.shadowBlur = 0;
            }

            // Draw progress bar (like CSS .progress-bar)
            const progressBarY = centerY + vinylRadius + 220;
            const progressBarWidth = exportCanvas.width * 0.8;
            const progressBarHeight = 6; // Increased height for better visibility
            const progressBarX = (exportCanvas.width - progressBarWidth) / 2;
            
            // Progress bar background with rounded corners
            exportCtx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            exportCtx.save();
            exportCtx.beginPath();
            const bgRadius = progressBarHeight / 2;
            exportCtx.moveTo(progressBarX + bgRadius, progressBarY);
            exportCtx.lineTo(progressBarX + progressBarWidth - bgRadius, progressBarY);
            exportCtx.quadraticCurveTo(progressBarX + progressBarWidth, progressBarY, progressBarX + progressBarWidth, progressBarY + bgRadius);
            exportCtx.lineTo(progressBarX + progressBarWidth, progressBarY + progressBarHeight - bgRadius);
            exportCtx.quadraticCurveTo(progressBarX + progressBarWidth, progressBarY + progressBarHeight, progressBarX + progressBarWidth - bgRadius, progressBarY + progressBarHeight);
            exportCtx.lineTo(progressBarX + bgRadius, progressBarY + progressBarHeight);
            exportCtx.quadraticCurveTo(progressBarX, progressBarY + progressBarHeight, progressBarX, progressBarY + progressBarHeight - bgRadius);
            exportCtx.lineTo(progressBarX, progressBarY + bgRadius);
            exportCtx.quadraticCurveTo(progressBarX, progressBarY, progressBarX + bgRadius, progressBarY);
            exportCtx.fill();
            exportCtx.restore();
            
            // Progress bar fill (like CSS background: linear-gradient(90deg, #667eea, #764ba2))
            const progressPercent = exportAudio ? (exportAudio.currentTime / exportAudio.duration) : 0.33; // Dynamic progress
            const progressWidth = progressBarWidth * progressPercent;
            const progressGradient = exportCtx.createLinearGradient(progressBarX, progressBarY, progressBarX + progressWidth, progressBarY);
            progressGradient.addColorStop(0, '#667eea');
            progressGradient.addColorStop(1, '#764ba2');
            
            exportCtx.fillStyle = progressGradient;
            exportCtx.save();
            exportCtx.beginPath();
            const fillRadius = progressBarHeight / 2;
            exportCtx.moveTo(progressBarX + fillRadius, progressBarY);
            exportCtx.lineTo(progressBarX + progressWidth - fillRadius, progressBarY);
            exportCtx.quadraticCurveTo(progressBarX + progressWidth, progressBarY, progressBarX + progressWidth, progressBarY + fillRadius);
            exportCtx.lineTo(progressBarX + progressWidth, progressBarY + progressBarHeight - fillRadius);
            exportCtx.quadraticCurveTo(progressBarX + progressWidth, progressBarY + progressBarHeight, progressBarX + progressWidth - fillRadius, progressBarY + progressBarHeight);
            exportCtx.lineTo(progressBarX + fillRadius, progressBarY + progressBarHeight);
            exportCtx.quadraticCurveTo(progressBarX, progressBarY + progressBarHeight, progressBarX, progressBarY + progressBarHeight - fillRadius);
            exportCtx.lineTo(progressBarX, progressBarY + fillRadius);
            exportCtx.quadraticCurveTo(progressBarX, progressBarY, progressBarX + fillRadius, progressBarY);
            exportCtx.fill();
            exportCtx.restore();
            
            // Scrubber thumb (like CSS progress thumb)
            const thumbX = progressBarX + progressWidth;
            const thumbY = progressBarY + progressBarHeight / 2;
            const thumbRadius = 8;
            
            // Thumb shadow
            exportCtx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            exportCtx.shadowBlur = 6;
            exportCtx.shadowOffsetX = 0;
            exportCtx.shadowOffsetY = 2;
            
            // Thumb body
            exportCtx.fillStyle = '#ffffff';
            exportCtx.beginPath();
            exportCtx.arc(thumbX, thumbY, thumbRadius, 0, 2 * Math.PI);
            exportCtx.fill();
            
            // Thumb border
            exportCtx.shadowBlur = 0;
            exportCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            exportCtx.lineWidth = 1;
            exportCtx.beginPath();
            exportCtx.arc(thumbX, thumbY, thumbRadius, 0, 2 * Math.PI);
            exportCtx.stroke();
            
            // Time labels (like CSS time display) - dynamic based on audio
            exportCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            exportCtx.font = `${exportCanvas.width * 0.03}px 'Patrick Hand', Arial, sans-serif`;
            exportCtx.textAlign = 'left';
            
            // Format time helper function
            const formatTime = (seconds) => {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            };
            
            // Current time (dynamic if audio is available)
            const currentTime = exportAudio ? exportAudio.currentTime : 20;
            const totalTime = exportAudio ? exportAudio.duration : 59;
            
            exportCtx.fillText(formatTime(currentTime), progressBarX, progressBarY + 20);
            
            exportCtx.textAlign = 'right';
            exportCtx.fillText(formatTime(totalTime), progressBarX + progressBarWidth, progressBarY + 20);
            
            // Draw control buttons (like CSS control buttons)
            const buttonY = progressBarY + 50;
            const buttonSize = exportCanvas.width * 0.08;
            const buttonSpacing = exportCanvas.width * 0.12;
            const startButtonX = (exportCanvas.width - (5 * buttonSize + 4 * buttonSpacing)) / 2;
            
            // Control button icons
            const buttonIcons = ['üîä', '‚èÆ', '‚ñ∂', '‚è≠', 'üîÅ'];
            
            // Control buttons with enhanced shadows and icons
            for (let i = 0; i < 5; i++) {
                const buttonX = startButtonX + i * (buttonSize + buttonSpacing) + buttonSize/2;
                const buttonYCenter = buttonY + buttonSize/2;
                
                // Button shadow
                exportCtx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                exportCtx.shadowBlur = 8;
                exportCtx.shadowOffsetX = 0;
                exportCtx.shadowOffsetY = 3;
                
                // Button body with better visibility
                exportCtx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                exportCtx.beginPath();
                exportCtx.arc(buttonX, buttonYCenter, buttonSize/2, 0, 2 * Math.PI);
                exportCtx.fill();
                
                // Button border
                exportCtx.shadowBlur = 0;
                exportCtx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                exportCtx.lineWidth = 2;
                exportCtx.beginPath();
                exportCtx.arc(buttonX, buttonYCenter, buttonSize/2, 0, 2 * Math.PI);
                exportCtx.stroke();
                
                // Button icon
                exportCtx.fillStyle = '#ffffff';
                exportCtx.font = `${buttonSize * 0.4}px Arial`;
                exportCtx.textAlign = 'center';
                exportCtx.textBaseline = 'middle';
                exportCtx.fillText(buttonIcons[i], buttonX, buttonYCenter);
            }
            
            // Update vinyl rotation
            vinylRotation += 0.5;
        }

        // Start video recording
        async function startVideoRecording(audioFile, songTitle, artistName, albumArtFile) {
            // Prevent duplicate exports
            if (isExporting) {
                return;
            }
            isExporting = true;
            
            let exportTimeout = null;
            
            try {
                // Set overall timeout (5 minutes)
                exportTimeout = setTimeout(() => {
                    window.parent.postMessage({
                        type: 'EXPORT_ERROR',
                        error: 'Export timeout. Please try again with a shorter audio file.'
                    }, '*');
                }, 5 * 60 * 1000);
                
                // Send initial progress update
                window.parent.postMessage({
                    type: 'EXPORT_PROGRESS',
                    progress: 5,
                    message: 'Initializing export...'
                }, '*');
                
                // Create export canvas
                createExportCanvas();

                // Load album art if provided
                if (albumArtFile) {
                    window.parent.postMessage({
                        type: 'EXPORT_PROGRESS',
                        progress: 10,
                        message: 'Loading album art...'
                    }, '*');
                    
                    albumArtImage = new Image();
                    albumArtImage.src = URL.createObjectURL(albumArtFile);
                    await new Promise((resolve) => {
                        albumArtImage.onload = resolve;
                    });
                }

                // Create audio element for recording
                window.parent.postMessage({
                    type: 'EXPORT_PROGRESS',
                    progress: 15,
                    message: 'Loading audio...'
                }, '*');
                
                const audioUrl = URL.createObjectURL(audioFile);
                exportAudio = new Audio(audioUrl);
                
                // Store current lyrics for export
                exportLyrics = [...lyrics];
                
                // Wait for audio to load
                await new Promise((resolve, reject) => {
                    exportAudio.addEventListener('loadedmetadata', resolve);
                    exportAudio.addEventListener('error', reject);
                    // Timeout after 10 seconds
                    setTimeout(() => reject(new Error('Audio loading timeout')), 10000);
                });

                // Create MediaRecorder with audio
                const canvasStream = exportCanvas.captureStream(30); // 30 FPS
                
                // Create audio context and connect to audio element
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaElementSource(exportAudio);
                const destination = audioContext.createMediaStreamDestination();
                source.connect(destination);
                source.connect(audioContext.destination);
                
                // Combine video and audio streams
                const combinedStream = new MediaStream([
                    ...canvasStream.getVideoTracks(),
                    ...destination.stream.getAudioTracks()
                ]);
                
                // Check for supported MIME types
                let mimeType = 'video/webm';
                if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9,opus')) {
                    mimeType = 'video/webm;codecs=vp9,opus';
                } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8,opus')) {
                    mimeType = 'video/webm;codecs=vp8,opus';
                } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
                    mimeType = 'video/webm;codecs=vp9';
                } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) {
                    mimeType = 'video/webm;codecs=vp8';
                } else if (MediaRecorder.isTypeSupported('video/webm')) {
                    mimeType = 'video/webm';
                } else if (MediaRecorder.isTypeSupported('video/mp4')) {
                    mimeType = 'video/mp4';
                }
                
                window.parent.postMessage({
                    type: 'EXPORT_PROGRESS',
                    progress: 20,
                    message: 'Setting up video recorder with audio...'
                }, '*');
                
                mediaRecorder = new MediaRecorder(combinedStream, {
                    mimeType: mimeType
                });

                recordedChunks = [];

                mediaRecorder.ondataavailable = function(event) {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = function() {
                    // Clear timeout
                    if (exportTimeout) {
                        clearTimeout(exportTimeout);
                    }
                    
                    const blob = new Blob(recordedChunks, { type: mimeType });
                    
                    // Convert to MP4 using FFmpeg.js (we'll use a simpler approach)
                    // For now, we'll export as WebM and let the user convert if needed
                    const fileName = `${songTitle.replace(/[^a-zA-Z0-9]/g, '_')}_vinyl_video.webm`;
                    
                    // Send completion message to settings
                    try {
                        // Send to parent window (index.html)
                        window.parent.postMessage({
                            type: 'EXPORT_COMPLETE',
                            videoBlob: blob,
                            fileName: fileName
                        }, '*');
                        
                        // Also try sending to top window
                        if (window.top && window.top !== window) {
                            window.top.postMessage({
                                type: 'EXPORT_COMPLETE',
                                videoBlob: blob,
                                fileName: fileName
                            }, '*');
                        }
                        
                    } catch (e) {
                        console.error('Error sending completion message:', e);
                    }
                };

                // Start recording
                window.parent.postMessage({
                    type: 'EXPORT_PROGRESS',
                    progress: 25,
                    message: 'Starting recording...'
                }, '*');
                
                mediaRecorder.start();

                // Start audio playback
                exportAudio.play();

                // Start rendering loop
                function renderLoop() {
                    renderToCanvas();
                    exportAnimationId = requestAnimationFrame(renderLoop);
                }
                renderLoop();

                // Update progress
                const duration = exportAudio.duration;
                const startTime = Date.now();
                
                const progressInterval = setInterval(() => {
                    const elapsed = (Date.now() - startTime) / 1000;
                    const progress = Math.min((elapsed / duration) * 100, 100);
                    
                    window.parent.postMessage({
                        type: 'EXPORT_PROGRESS',
                        progress: progress,
                        message: `Recording... ${Math.round(progress)}%`
                    }, '*');

                    if (elapsed >= duration) {
                        clearInterval(progressInterval);
                        stopVideoRecording();
                    }
                }, 100);

            } catch (error) {
                // Clear timeout
                if (exportTimeout) {
                    clearTimeout(exportTimeout);
                }
                
                // Clean up resources
                if (exportAudio) {
                    exportAudio.pause();
                    exportAudio = null;
                }
                if (albumArtImage) {
                    URL.revokeObjectURL(albumArtImage.src);
                    albumArtImage = null;
                }
                if (exportAnimationId) {
                    cancelAnimationFrame(exportAnimationId);
                    exportAnimationId = null;
                }
                
                // Reset export flag
                isExporting = false;
                
                window.parent.postMessage({
                    type: 'EXPORT_ERROR',
                    error: error.message || 'Unknown error occurred'
                }, '*');
            }
        }

        // Stop video recording
        function stopVideoRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
            
            if (exportAnimationId) {
                cancelAnimationFrame(exportAnimationId);
                exportAnimationId = null;
            }
            
            if (exportAudio) {
                exportAudio.pause();
                exportAudio = null;
            }
            
            // Clean up album art image
            if (albumArtImage) {
                URL.revokeObjectURL(albumArtImage.src);
                albumArtImage = null;
            }
            
            // Reset export flag
            isExporting = false;
        }

        // Debug browser support
        function debugBrowserSupport() {
            const support = {
                mediaRecorder: !!window.MediaRecorder,
                canvas: !!document.createElement('canvas').getContext,
                audio: !!window.Audio,
                webm: MediaRecorder.isTypeSupported('video/webm'),
                webm_vp8: MediaRecorder.isTypeSupported('video/webm;codecs=vp8'),
                webm_vp9: MediaRecorder.isTypeSupported('video/webm;codecs=vp9'),
                mp4: MediaRecorder.isTypeSupported('video/mp4'),
                userAgent: navigator.userAgent
            };
            
            console.log('Browser Support Debug:', support);
            
            let message = 'Browser Support Check:\n\n';
            message += `MediaRecorder: ${support.mediaRecorder ? '‚úÖ' : '‚ùå'}\n`;
            message += `Canvas: ${support.canvas ? '‚úÖ' : '‚ùå'}\n`;
            message += `Audio: ${support.audio ? '‚úÖ' : '‚ùå'}\n`;
            message += `WebM: ${support.webm ? '‚úÖ' : '‚ùå'}\n`;
            message += `WebM VP8: ${support.webm_vp8 ? '‚úÖ' : '‚ùå'}\n`;
            message += `WebM VP9: ${support.webm_vp9 ? '‚úÖ' : '‚ùå'}\n`;
            message += `MP4: ${support.mp4 ? '‚úÖ' : '‚ùå'}\n\n`;
            message += `Browser: ${navigator.userAgent.split(' ')[0]}`;
            
            alert(message);
        }

        // Listen for export messages from settings
        window.addEventListener('message', function(event) {
            if (event.data.type === 'DEBUG_BROWSER_SUPPORT') {
                debugBrowserSupport();
            } else if (event.data.type === 'EXPORT_MP4') {
                // Prevent duplicate exports
                if (isExporting) {
                    return;
                }
                
                const { audioFile, songTitle, artistName, albumArtFile } = event.data;
                
                // Check if MediaRecorder is supported
                if (!window.MediaRecorder) {
                    window.parent.postMessage({
                        type: 'EXPORT_ERROR',
                        error: 'MediaRecorder API is not supported in this browser. Please use Chrome, Firefox, or Edge.'
                    }, '*');
                    return;
                }
                
                // Update UI with export data
                if (songTitle) {
                    document.getElementById('songTitle').textContent = songTitle;
                }
                if (artistName) {
                    document.getElementById('artistName').textContent = artistName;
                }
                
                // Start recording
                startVideoRecording(audioFile, songTitle, artistName, albumArtFile);
            }
        });
    </script>
</body>
</html>